My computer science program is a program that helps find blue colours in images given by the user. This program can be very useful, especially in an ocean related setting as it can help spot corals. Corals are an important contributor that helps provide oxygen to the Earth and support biodiversity. Using 10 images I chose, with consideration to have barely any fish or blue corals to affect the program, I will prove the usefulness of my program in a real-world case. Blue corals are one of the rarer species of corals, so the fact that I cannot use this program with blue corals will not affect the usefulness of the program deeply (https://www.saltwateraquariumblog.com/coral-colors/
) (This website shows the rarity of the corals, supporting the fact that just because blue corals cannot be used in this program, it will not affect the usefulness of the program deeply because blue corals are rare and not as common as other coloured corals.). My program is programmed to recognize the ocean colour using a range of blue shades. As you know, corals are not the colour of the ocean. If you subtract the amount of pixels the entire image has from the amount of blue pixels, you will get the remaining pixels that are not blue, which in my case are corals. This program also tells you the time it takes to analyze each photo to 3 decimal places. This makes it easy to tell how image size and the amount of pixels affect the performance of the program. Once all the images are processed, they get stored into the master list which sorts the images from the highest blue pixel percentage to the lowest blue pixel percentage. This program then shows you the top five images that have the most amount of blue pixels, which means the ones that have the least amount of corals. Binary search is implemented into the program to find an image closest to the minimum amount of blue pixels the user wants to find without going under that minimum. This helps you find oceans that meet this amount of coral. By seeing that one part of the ocean has 90% blue as a minimum, you can see it does not have as many corals. By analyzing large numbers of ocean images automatically, similar techniques could assist researchers in tracking reef coverage or changes over time. This program makes lighter and darker blue pixels weigh less than the bluer blue pixels. This reduces the chance of false positives from clouds, sun, shadows, and sand. A pale or darker blue will not distort the image in any way, giving more reliable data for monitoring coral reef health. Counting stronger blue pixels helps better estimate how much open water vs corals exist. Weighting by blue intensity helps normalize across images, so even a slightly darker or lighter photo will not be unfairly scored lower or higher.


TESTING AND DEBUGGING
This program was tested with 10 images in very different looking settings. Images that had more open water and more corals consistently had more blue percentages than images that have more corals and less open water. I made sure the RGB scanner can correctly identify ocean water (blue) without accidentally identifying other objects like fish or seaweed. I tested the program to see if the amount of blue pixels amounted to the amount of blue pixels I estimated across all the images. Edge cases, like darker images or images with more shadows, were tested to see if the program still worked the way it should work consistently. Other edge cases, like images with very small amounts of blue were tested to see if the program would act up.


CODE PROFILING EXAMPLE:
Image: ocean2, percentage of blue pixels: 39.45%, time taken for the program to process the image: 1.952 seconds. This shows that the higher resolution an image has (more pixels), the longer it takes because more pixels must be processed. The checking of the image takes up most of the execution time, the other small changes in pixel times when you run the program again can be due to other computer parts running, which can slightly modify the result of execution time. The time it takes is being done using the time.time() function from Python's time module.


PERFORMANCE ANALYSIS:
Pixel scanning takes up most of the time reported back to you because every pixel has to be examined. Sorting and searching the images do not take a lot of time because all the info you need has already been achieved by pixel scanning, and there are not many images to sort or use binary search on. This shows you that pixel scanning and image resolution are the major impact on performance of the program. You can compare an image like ocean2 with an image like ocean10. Ocean10 clearly has lower resolution, while ocean2 has a higher resolution which means ocean2 would take more time to process.  The slowest part of this program is scanning every pixel in each image, because every pixel must be checked one by one. Images with higher resolution will take a longer time than one with a lower resolution. Sorting and binary search are faster because they work with a small list of image results. This program is designed so each image is scanned only once to avoid more work.


CHALLENGES FACED:
One of my biggest challenges was finding an RGB range that would fit the accurate colour of the ocean water. It has to be able to tell if there was blue in a darker or brighter image. A range that was too wide would clearly be seen because an estimate of the amount of blue pixels was not close at all, causing incorrect data. A range too narrow would cause some blue pixels to be missed and misinterpreted for something else. This issue was solved through retesting the RGB range for all the images until all the images were close to the amount of blue pixels I estimated. Another challenge was how the program handled shadows or darker images and lighter images. Having a perfect range meant detecting pixels that were a darker blue or lighter blue without detecting other colours of pixels by accident. This issue was solved also through retesting the program many times until I got the result close to my estimate. The program uses the function is_target_colour(r, g, b) to identify blue pixels. It detects blue and greenish-blue ocean water pixels accurately and does not detect non-blue pixels such as pink, purple, yellow, or white, and handles brightness and shadows across different images.


ALGORITHMS AND EFFICIENCY
Selection sort: This was implemented to sort the images from most blue pixels to least blue pixels, finding which image had the most amount of ocean water compared to the amount of corals there are.
Binary search: This was implemented to look for the minimum amount of blue pixels there are. So when the user needs to find an ocean that has a lot of ocean water compared to the amount of corals, or a lot of corals compared to the amount of ocean water, it can be easily found in minimal time.
Efficiency: Pixel counting can take a long amount of time depending on how high of a resolution an image has. Pixel counting is the most time consuming part of this program. Measuring the amount of time it takes to count the amount of pixels can show how efficient my program is at taking images of different resolution and help optimize code.
